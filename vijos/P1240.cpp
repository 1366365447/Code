/*
的确是一道非常好的dp好题(多重背包)
状态蛮多的	限时5s也是醉了
不过正确的dp一个点也就1100ms--？
然后对于这个状态定义	表示非常尴尬
我们首先要弄清楚这个情况
如果有两对夫妻分别在不同的房间，那么完全可以将它们拆散，使得两男两女分别在两个不同的房间。
这样可以使房间的容量得到最大限度的利用。
所以说我们每个人数只有两个对应状态
有一对夫妻的	和一对都没有的
那么这样我们就可以自然而然地想到这样的状态定义
设f[i][j][k][0]表示前i个房间，男的放了j个女的放了k个的最优值，且没有夫妻在同一房间中
设f[i][j][k][1]表示前i个房间，男的放了j个女的放了k个的最优值，且有一对夫妻在同一房间中。
这道题的限制条件很多，一定不能漏了任何一个条件和状态不然就gg了
我们仔细看一下初步有这样的状态转移方程
f[i][j][k][0]=min(f[i-1][j][k][0],f[i-1][j-v][k][0]+pi,f[i-1][j][k-v][0]+pi);
f[i][j][k][1]=min(f[i-1][j][k][1],f[i-1][j-1][k-1][0]+pi,f[i-1][j-v][k][1]+pi,f[i-1][j][k-v][1]+pi);
其中v会属于[1,(第i个旅馆的最大容纳量)]
怎么解释这个状态转移方程呢
我们先看
f[i][j][k][0]=min(f[i-1][j][k][0],f[i-1][j-v][k][0]+pi,f[i-1][j][k-v][0]+pi);
意思就是我们可以选择这个房间不放任何人，然后这个房间放v个男生,或者放v个女生
就是在不放夫妻的情况下，我们只有这三个决策
很明显这满足最优子结构的性质并且包括了所有可能到达最优解的决策和状态
再看第二个状态转移方程
f[i][j][k][1]=min(f[i-1][j][k][1],f[i-1][j-1][k-1][0]+pi,f[i-1][j-v][k][1]+pi,f[i-1][j][k-v][1]+pi);
同样第一个是不选择这个房间，第二个是放一对夫妻进去的情况
(因为原来是没有夫妻的情况，而且夫妻是减少一个男的一个女的所以是f[i-1][j-1][k-1][0])
第三个就是原来已经有夫妻了，然后选择v个男生
同理最后一个就是选择v个女生了
但我们要注意到，因为f[][][][1]是已经放了一对夫妻了
所以我们肯定是要满足已经放了男生j>=1 且已经放的女生k>=1	并且当前旅馆容量>=2
所以在决策之前要加上这个判断
然后枚举v	然后不断更新值就好了
详细见代码吧Orz
而且这道题目好像并没有无解的情况？
一开始忘记判断无解了交上去都AC了66666
还看到一种三维的做法(百度就好)
但是看到位大犇这样说
{
至于网上流传的一个三维的数组，请试试以下数据。
【test.in】
6 6 5 2
2 5
2 6
3 5
5 1
5 2
【test.out】
8
这是我在测试网上流传的题解程序时发现的问题，程序会出现10以上的解。
}
所以就不做死尝试了
Orz又是一道神犇题
让我这种弱比抄对了2333333
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iomanip>
#include <cstdlib>
using namespace std;

const int MAXN=302;
const int INF=0x7fffffff;
struct node
{
	int v,w;
}a[MAXN];
int f[MAXN][MAXN][MAXN][2];
int m,n,r,c;
int ans=INF;
int temp;

void init()
{
	cin>>n>>m>>r>>c;
	for(int i=1;i<=r;i++)
		cin>>a[i].v>>a[i].w;
	memset(f,0x3f,sizeof(f));
	temp=f[1][1][1][1];
}

int main()
{
	init();
	f[0][0][0][0]=0;
	for(int i=1;i<=r;i++)
		for(int j=n;j>=0;j--)
			for(int k=m;k>=0;k--)
			{
				if(a[i].v>=2&&j>=1&&k>=1)
					f[i][j][k][1]=min(f[i-1][j-1][k-1][0]+a[i].w,f[i-1][j][k][1]);
				f[i][j][k][0]=min(f[i][j][k][0],f[i-1][j][k][0]);
				for(int v=1;v<=a[i].v;v++)
				{
					if(j-v>=0)
					{
						f[i][j][k][0]=min(f[i][j][k][0],f[i-1][j-v][k][0]+a[i].w);
						f[i][j][k][1]=min(f[i][j][k][1],f[i-1][j-v][k][1]+a[i].w);
					}
					if(k-v>=0)
					{
						f[i][j][k][0]=min(f[i][j][k][0],f[i-1][j][k-v][0]+a[i].w);
						f[i][j][k][1]=min(f[i][j][k][1],f[i-1][j][k-v][1]+a[i].w);					}
				}
			}
	ans=min(f[r][n][m][0],f[r][n][m][1]);
	if(ans==temp)
		cout<<"Impossible"<<endl;
	else
		cout<<ans<<endl;
	return 0;
}
     