/*
0/1背包的第K优解问题，在背包九讲中有
引用一下其中的内容
{
求次优解、第K优解
对于求次优解、第K优解类的问题，如果相应的最优解问题能写出状态转移方程、用动态规划解决，那么求次优解往往可以相同的复杂度解决，第K优解则比求最优解的复杂度上多一个系数K。
其基本思想是将每个状态都表示成有序队列，将状态转移方程中的max/min转化成有序队列的合并。这里仍然以01背包为例讲解一下。
首先看01背包求最优解的状态转移方程：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}。如果要求第K优解，那么状态f[i][v]就应该是一个大小为K的数组f[i][v][1..K]。其中f[i][v][k]表示前i个物品、背包大小为v时，第k优解的值。“f[i][v]是一个大小为K的数组”这一句，熟悉C语言的同学可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然f[i][v][1..K]这K个数是由大到小排列的，所以我们把它认为是一个有序队列。
然后原方程就可以解释为：f[i][v]这个有序队列是由f[i-1][v]和f[i-1][v-c[i]]+w[i]这两个有序队列合并得到的。有序队列f[i-1][v]即f[i-1][v][1..K]，f[i-1][v-c[i]]+w[i]则理解为在f[i-1][v-c[i]][1..K]的每个数上加上w[i]后得到的有序队列。合并这两个有序队列并将结果（的前K项）储存到f[i][v][1..K]中的复杂度是O(K)。最后的答案是f[N][V][K]。总的复杂度是O(NVK)。
为什么这个方法正确呢？实际上，一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。只不过由于是求最优解，所以其它在任何一个策略上达不到最优的方案都被忽略了。如果把每个状态表示成一个大小为K的数组，并在这个数组中有序的保存该状态可取到的前K个最优值。那么，对于任两个状态的max运算等价于两个由大到小的有序队列的合并。
另外还要注意题目对于“第K优解”的定义，将策略不同但权值相同的两个方案是看作同一个解还是不同的解。如果是前者，则维护有序队列时要保证队列里的数没有重复的。
}
嗯说一下自己的理解吧
和0/1背包普通问题一样 我们定义f[j]表示已用体积为j时，所能达到的最大价值
嗯因为我们要求前k优解 所以我们肯定是要定义状态f[j][k]表示已用体积为j时，所能达到的价值的第k优解
这个定义一出来 我们知道对于每个状态f[j]都有对应的k个解
其实和0/1本质一模一样的   我们0/1是f[j]=max{f[j],f[j-v[i]]+w[i]}
而我们这里要维护的是前k个解，就应该让f[i]和f[j-v[i]]+w[i](即选和不选)这里的2*k个方案中
选出第最优的k个方案来
这个过程是不是让我们想到了归并排序(用来按顺序合并两个有序数列)
因为对于f[i][1]-f[i][k]一定是有序的
所以我们用归并排序合并一下两个序列的前k大值
其实还是很好理解的~
主要是看代码了然后自己写几遍就好
Orz我越来越弱了
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXV=5005;
const int MAXSIZE=52;
const int INF=0x7ffffff;
int f[MAXV][MAXSIZE];
int k,n,V;
int ans;

void mege(int cur,int v,int w)
{
    int temp[MAXSIZE];
    int i=1,j=1,t=1;
    while(t<=k)
    {
        if(f[cur][i]>f[cur-v][j]+w)
            temp[t++]=f[cur][i++];
        else
            temp[t++]=f[cur-v][j++]+w;
    }
    for(int i=1;i<=k;i++)
        f[cur][i]=temp[i];
}


int main()
{
    cin>>k>>V>>n;
    for(int i=0;i<=V;i++)
        for(int j=0;j<=k;j++)
            f[i][j]=-INF;
    f[0][1]=0;
    int v,w;
    for(int i=1;i<=n;i++)
    {
        cin>>v>>w;
        for(int j=V;j>=v;j--)
            mege(j,v,w);
    }
    for(int i=1;i<=n;i++)
        ans+=f[V][i];
    cout<<ans<<endl;
    return 0;
}
     