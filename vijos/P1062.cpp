/*
先解释一下样例
6
4 5 6 6 6 6
1 1 1 4 5 6
男 男 男 男 女 男 女 男 女 女 女 女
这道题常规做法可以用栈做，模拟一下即可了
但是其实有更加简单方便的做法
首先我们要弄清楚这个关系
对于一个女生，她的男舞伴的位置满足：
从左向右考虑女生，并从女生位置向左扫描，当扫到第一个未被匹配的男生时
则必然有该男生就是该女生的男舞伴
接下来我们给出证明：
    由题意可知，对于每一对舞伴之间，要么没有人，要么有成对的舞伴。那么我们
对于第一个扫描到的男生，如果不是当前女生的舞伴，那么必然是当前女生右边的某个
女生的舞伴，则中间会有一个单身狗233>3<易知不可能成立
所以我们可以利用这个性质直接乱推一下过去
a[i]表示第i个女生和i-1中间的未匹配男生数
k用来找合适的男生位置，即从女生位置右向走，知道找到一个a[i]到a[i-1]还有未匹配男生位置的地方
则可以匹配上去，距离为i-k+1(要包括该男生)
注意匹配完后a[k]--,即匹配掉了一个男生，数量减1
这样就解决了这道题
                                                    Powder
*/
#include <cstdio>
#include <iostream>
using namespace std;

const int maxn=2000;
int a[maxn];
int n;
int t1,t2;

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)//对于每输入一个i都可直接计算出来
    {
        cin>>t1;//输入个数(注意包括了自己的男性舞伴)
        a[i]=t1-t2;//相邻两个的差值(未匹配男生数)
        t2=t1;//更新
        int k=i;//从该女生位置开始找
        while(!a[k])//找有未匹配男生的位置匹配其左边第一个~
            k--;
        cout<<i-k+1<<" ";//包括自己的男生舞伴~
        a[k]--;//匹配掉了一个
    }
    return 0;
}