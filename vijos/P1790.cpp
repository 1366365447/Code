/*
很明显可以拓扑排序做
但是这句话却才是关键
优美的编号方案有很多种，国王希望使1号城市的编号尽可能小，
在此前提下，使得2号城市的编号尽可能小...依此类推。
一开始是想正向直接输出最小的
写了一遍发现根本不对啊
仔细想想发现正向贪心可能导致前面的点的编号很大，所以就用逆向贪心，、
{
注意逆拓扑序的意思是
1.翻转输入的所有边. 输入中若有u->v,则构图时是v->u.
2.用优先队列挑字典序最大的一组.即,如果队列中有多个元素,选编号最大的那个.
3.逆编号.第一个挑出来的城市赋值为n,第二个为n-1...最后一个为1.
}
每次找入度为零且编号尽量大的点，把它放在拓扑序列的列首，并且删除所有指向这个点的有向边。
代码实现如下，维护一个优先队列，只有当一个点的入度为零的时候才将它入队。
题意就是拓扑排序,要求1的序号尽可能小,然后2的序号尽可能小，3,4...
一开始很容易想到直接贪心,每次选一个入度为0的点,如果有多个,就选编号最小的那个,但是很容易找到反例。
看了下题解,应该是反着做拓扑排序,每次取编号最大的,但是没有人给出证明。下面给出我的证明,欢迎指出错误。
ps：参考了一位大牛的文章,poj有一道题类似，参考了他的题解,但是找不到了,所以没法放出他的链接了,先道歉。
假设我们按逆拓扑排序的方法求出了一个拓扑序列（把得到的反序列正过来）,记为A。
假设最优解的拓扑序列是B。
从后往前比较AB,设在位置k,AB第一次出现不同。即A[k]!=B[k],A[p]=B[p].
显然根据我们的贪心策略"每次取的是编号最大的"，有A[k]>B[k].
那么我们在B中取寻找A[k],即找到B[p]=A[k].
然后把B中B[p],B[p+1]...B[k]这一段拿出来,记为序列C。
因为B[p]=A[k] , 把B[p]换成A[k],C=A[k],B[p+1]....B[k].
很显然在C中A[k]不是最小的,因为至少B[k]比它小。 假设C中最小的是B[q],那么我们可以构造出一个序列D.
D=B[p+1],B[p+2]...B[q],A[k],B[q+1]...B[k]. (实质就是把A[k]移到B[q]的后面）
显然这个序列会比序列C更优,因为B[q]的名次靠前了一名。 那么如果把C换成D会更优,与B是最优解矛盾。
那么怎么知道序列D一定是合法的呢？因为如果A[k]恰好是B[p+1]的前驱,那么就不能把A[k]移走。
所以我们回到序列A,序列A中A[k]是AB序列从右往左第一个不同的元素,那么在A中,B[p+1]肯定是在A[k]前面的,所以A[k]不可能是B[p+1]的前驱。
综上,我们得到的答案就是最优解。
换句话说吧
我们把边反转一下
那么实际上我们统计的就是点的出度了(出边变入边,入边变出边)
然后实际上我们每次队列中处理的就是出度为0即要在最后的点了
每次将队列中的一个出度为0的点加到拓扑序列的最后面
然后这里我们用一个优先队列每次保证取出的这个点的编号最大
因为后面的更大了肯定前面的就会更小(上面其实有证明了)
然后就可以直接顺序输出拓扑序列就好了
长见识了
Orz搞不懂就多看几遍吧
*/
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;

const int maxn = 100000 + 10;
const int maxm = 200000 + 10;

int n, m;
int clock;
int cnt[maxn], id[maxn];
vector<int> G[maxn];
priority_queue<int> q;

int main () {
    cin >> n >> m;

    for(int i=1;i<=m;i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        cnt[u]++;
        G[v].push_back(u);
    }

    for (int i=1;i <=n;i++) 
        if (!cnt[i]) 
            q.push(i);

    clock = n;//时间戳
    while (!q.empty()) 
    {
        int u = q.top(); 
        q.pop();
        
        id[u] = clock--;
        int d=G[u].size();
        for (int i= 0;i<d;i++) 
        {
            int v=G[u][i];
            cnt[v]--;
            if(cnt[v] == 0) 
                q.push(v);
        }
    }
    for (int i=1;i <=n;i++) 
        printf("%d ", id[i]);
    return 0;
}