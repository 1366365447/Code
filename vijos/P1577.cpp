/*
尼克的任务Orz一模一样
就是一个DP的LIS，水啊？！
好好琢磨这段话
{
当XX从放假的第一分钟起就要开始赶作业。
如果在同一时刻有多个作业需要完成，XX可以选其中的一个来做，
而其余的则可以由其他的同学帮他来完成，反之如果只有一个作业，则该作业必须由XX去完成，
假如某些作业开始时刻XX正在工作，则这些作业也由XX的同学来帮他完成。
如果某作业于第P分钟开始，持续时间为T，则该作业将在第P+T-1分钟结束
}
我们可以想到这样一个状态
f[i]表示第i分钟到结束的最大空闲时间，
则若i时刻没有开始的任务，则f[i]=f[i+1]+1
若i时刻有开始的任务（一个或多个），则要枚举来选择f[i]:=max(f[i],f[i+a[i,j]]),
a[i,j] 表示第i时刻开始的第j个任务的耗时。即持续时间t
初始化没有什么特别的地方。就是f[k+1]=0，答案就是f[1]
先要按照开始时间排序一下，时间复杂度O(N+K).
怎么理解呢
我们看到如果i时刻没有要开始的任务
那么这一分钟肯定是可以休息的Orz
然后就f[i]=f[i+1]+1
不然的话就肯定要做事情
而只能做这一分钟开始的事情
所以我们就直接枚举所有这一分钟开始的事情
然后取所有做的事情的情况所能达到的最大值就好了
看到几个题解讲的蛮好的
{
dp【i】表示从i开始的最大空闲时间，逆序推dp，
分情况：
1：如果改时间没有工作需要开始，那么当然是要休息的，表示现在休息一分钟，dp【i】=dp【i+1】+1
2：如果有需要开始的，那么在所有需要开始的工作中选一个最优的（废话），dp【他们的末尾时间+1】最大的，
来表示他们工作完之后最多能休息多长时间（注意恰好工作完的那一分钟，即工作的最后一分钟，不算休息）
这就是+1的原因 ，为什么？我们可以设想：对于每个任务，如果我做这个任务，那能得到的最大空暇时间是多少？
就是工作完之后的最大空余时间啊
不过，之所以要逆向推，你想啊。正向推的话，前面的选择会对后面的造成影响，并且我们没有办法来记录。
为什么要逆序DP呢？因为不难发现，选择是在任务的开始，不是任务的结束，要在同一起始点转移状态，必将从后往前，所以就有了本方法。
}
{
看了一下感觉大家的方法都很烦啊。。
用f[i]表示从i到n位置的最大空闲时间，p[i]表示第i个任务的开始时间,t[i]表示第i个任务的结束时间
从n开始到1枚举i，如果存在p[j]=i，那就说明此时的最优解必须选择一个任务来做，
所以我们就枚举所有p[j]=i的任务的结束时间，找到最大值的f[i+t[j]]转移到f[i],如果不存在任何一个任务p[j]=i，
那么说明此时的最优解可以偷懒，就直接用f[i+1]+1作为f[i]的值
*优化
我们发现输入数据是根据任务的开始时间有序的，所以每次使用的j肯定不会大于上一次的j，令j等于最后一个任务每次向前递减，时间复杂度非常好	
}
{
另一种方法：
求最大空闲时间即求最小消耗时间。
f[i]表示以第i个任务结尾的工作序列的最小消耗时间
把任务按照开始时间排序，以确保如果某一时刻无其他任务必须做一个。
f[i]=f[j]+cost(i) 仅当end(j)<start(i) 且 在区间(end(j),start(i))中无其他任务。
使用cnt(i)表示从1-i时刻有几个任务，如果cnt(a)==cnt(b)则说明a,b间无任务。	
}
嗯开阔思路了
好题目~
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN=10005;
struct node 
{
	int x,y;
	bool operator < (const node &b)const
	{
		return x<b.x;
	}
}a[MAXN];
int f[MAXN];

int main()
{
	int k,n;
	cin>>k>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1);
	f[k+1]=0;
	int j=n;
	for(int i=k;i>=1;i--)//逆序推
	{
		f[i]=0;
		if(a[j].x!=i)
			f[i]=f[i+1]+1;
		else 
		{
			while(a[j].x==i)//即枚举所有a[j].x==当前时间
			{
				f[i]=max(f[i],f[i+a[j].y]);//取所有的最大值，就是做了这件事情
				j--;
			}
		}
	}
	cout<<f[1]<<endl;
	return 0;
}
     