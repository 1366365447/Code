/*
NOI97的题目怎么跑到NOIP分类来了.....OTZ
有黑书的童鞋看到P119啦~讲的比窝好多惹~
窝们要先弄清题目的要求~
题目中对编号有要求，第k堆中任意一块积木的编号要大于第k+1堆中任意一块积木，
每一堆中，下面的积木编号要小于上面的积木编号，
也就是说，对于所给的积木，可以取或不取，但只能按顺序取，按顺序堆
对积木大小的要求，每一堆下面的积木要比上面的大
所以我们就不能排序套用DAG惹~
所以只要在转移某个状态的时候考虑上顺序就好啦
我们可以用DP，对m堆,n块积木枚举，在满足编号要求的前提下，枚举每一块积木的三条边
即用f[i][j][l]表示第i堆第j块积木以第l条边为高的最大高度
那么我们需要先枚举每一堆k
然后枚举第二维第i块木块
同时要更新这个状态f[k][i][]
必然要找到编号在i之前的某个j转移过来
那么从0~i-1枚举j(注意为什么是0)
同时因为某个方块堆在某个方块上
那么必然是要考虑9种情况的
即以哪条边为高(3*3)
所以就枚举一下并转移
同时要考虑一样选了和没选之后哪个更优保留更优解
最后找到最优的答案就好啦~QWQ
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN=105;
int f[MAXN][MAXN][3];//用f[i][j][l]表示第i堆第j块积木第l条边的最大高度
int a[MAXN][3];
int x1,x2,y1,y2;
int n,m;
int ans;

void init()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i][0]>>a[i][1]>>a[i][2];
}

int main()
{
	init();
	for(int k=1;k<=m;k++)
		for(int i=1;i<=n;i++)
			for(int j=0;j<i;j++)//从0开始
				for(int l1=0;l1<=2;l1++)
					for(int l2=0;l2<=2;l2++)
					{//某条边的下一条边(循环意义)即(l+1)%3，而做高的边就是(l+2)%3
						x1=max(a[i][l1],a[i][(l1+1)%3]);//i方块选取做底面的两边的长边
						y1=min(a[i][l1],a[i][(l1+1)%3]);//i方块选取做底面的两边的短边
						x2=max(a[j][l2],a[j][(l2+1)%3]);//j方块选取做底面的两边的长边
						y2=min(a[j][l2],a[j][(l2+1)%3]);//j方块选取做底面的两边的短边
						if(x1<=x2&&y1<=y2)//需要满足条件才可以尝试更新~！
							f[k][i][l1]=max(f[k][i][l1],f[k][j][l2]+a[i][(l1+2)%3]);//放或不放选更优
						f[k][i][l1]=max(f[k][i][l1],f[k-1][j][l2]+a[i][(l1+2)%3]);//和前一堆比较(自成一堆)
						ans=max(ans,f[k][i][l1]);//记录最优解
					}
	cout<<ans<<endl;
	return 0;
}
     