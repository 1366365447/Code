/*
用dp[i]来表示从1~i的位置能够使炸弹不爆炸的放置核物质的方案总数。
在写状态转移方程的时候考虑当i-1已经成功放完的情况下的总数为dp[i-1],
这时第i个有放和不放两种情况，共计2*dp[i-1]，
而若是放了会爆炸的话则必须是连续放置m个才会引起的爆炸。
因此设情况A为：从第i-m+1个一直到第i个（总共有m个）都是放置了核弹的，
这样的话第i-m个一定没有放置核弹（放了就炸了...) 
那么在满足后半部分即A情况这样的布雷前提下的所有情况总数为dp[i-m-1].因此得出状态转移方程：
dp[i]=2*dp[i-1] (i<m)
=2*dp[i-1]-1 (i==m)
=2*dp[i-1]-dp[i-m-1] (m<i<=n)
据说long long也是坑点。
嗯这个题解很清楚了
其实很好想到
dp[i]表示从1~i的位置能够使炸弹不爆炸的放置核物质的方案总数。
那么如果i<m 	那么肯定不可能会炸了
可以随便放或者不放	而这都是建立在dp[i-1]上
根据乘法原理咯 所以有2*dp[i-1]种
如果i==m
那么当前这个第i个坑也可以随便放
但是注意	一定有一种情况就是前i-1个坑
都放满了炸弹
这个时候就应该-这一个方案咯
如果n>=i>m
那么肯定是有一定要i-m+1个到i-1都要放满m-1个炸弹
然后再在这个第i个位置再放一个炸弹才会炸
所以就是要-dp[i-m-1]
因为只有一种可能一直放过来
所以就是*1就是本身咯
QWQ就做完了
真心好题
从二维推到一维
奇妙
*/
#include <iostream>
using namespace std;
long long dp[1000005];
int main(){
	int n,m;
	cin>>n>>m;
	dp[0]=1;
	for(int i=1;i<=n;i++)
	{
		if(i<m) 
			dp[i]=2*dp[i-1];
		else if(i==m) 
			dp[i]=2*dp[i-1]-1;
		else 
			dp[i]=dp[i-1]*2-dp[i-m-1];
	}
	cout<<dp[n]<<endl; 
	return 0;
} 