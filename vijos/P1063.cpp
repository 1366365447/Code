/*
一道找一个正三角形中包含的最大正三角形
{输入文件中出现空格，且空格只是为了保持整个三角形的形状。}
也是蛮烦人的这个东西，就只能老老实实用scanf输入吧
动态规划，表示没看懂题目
以为是要求向上和向下之和？
但好像答案是向下的？或者是数据太弱？
注意要判断ODD(奇偶性)
（1，2）（1，3）（1，4）
         （2，3）
显然不能形成一个三角形
所以我们对于能构成个向下的更大的三角形的顶点坐标一定有
x,y同奇偶，也只有满足这个条件才能继续递推
设f[i][j]表示以(i,j)为顶点的最大的正三角形规模
(规模1有1个，规模2有四个，规模3有九个QWQ)
则有
如果i,j同奇偶
并且满足a[i-1][j]=='-'&&a[i-1][j-1]=='-'&&a[i-1][j+1]=='-'
即这个顶点的上面一行的三个扩展点都要是可行点(就是穿了夏季校服的)
如果满足这两个条件，就说明这个点是可以尝试更新更优解的
f[i][j]=min(min(f[i-1][j-1]+1,f[i-1][j+1]+1),f[i-2][j]+2);
前两个就是上面的两个角顶点所能扩展的值+自身这一层的一个规模
而第三个就是要正对上面两行的那个点能扩展的最大值了
嗯因为如果要扩展到下面行(和下下面行)，那么肯定是要取最小值了
(自己好好体会~很难说明白)
Orz经典题目了 也蛮好的
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN=125;//开105最后一个点会爆啊Orz
char a[MAXN][MAXN];
int f[MAXN][MAXN];
int n;
int ans;

void init()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=i;j<i+2*n+1-2*i;j++)
			scanf(" %c",&a[i][j]);
	for(int i=1;i<=2*n-1;i++)
		if(a[1][i]=='-')
			f[1][i]=1,ans=1;
}

int main()
{
	init();
	for(int i=2;i<=n;i++)
		for(int j=i;j<=2*n-i;j++)
			if(a[i][j]=='-'&&((i+j)&1)==0)
			{
				f[i][j]=1;
				if(a[i-1][j]=='-'&&a[i-1][j-1]=='-'&&a[i-1][j+1]=='-')
					f[i][j]=min(min(f[i-1][j-1]+1,f[i-1][j+1]+1),f[i-2][j]+2);
				ans=max(ans,f[i][j]);
			}
	cout<<ans*ans<<endl;
	return 0;
}
     