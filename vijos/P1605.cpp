/*
一道二分图模型，真心不难做但是很难想到二分图做，根本是想不到这个性质证明
我也不太懂咯就借鉴一下别人的证明贴出来~
{
	考虑对于任意两个数q1[i]和q1[j]来说,它们不能压入同一个栈中的充要条件是什么
(注意没有必要使它们同时存在于同一个栈中,只是压入了同一个栈).实际上,这个条件p是:
存在一个k,使得i<j<k且q1[k]<q1[i]<q1[j]. 
首先证明充分性,即如果满足条件p,那么这两个数一定不能压入同一个栈.这个结论很显然,使用反证法可证. 
假设这两个数压入了同一个栈,那么在压入q1[k]的时候栈内情况如下: 
…q1[i]…q1[j]… 
因为q1[k]比q1[i]和q1[j]都小,所以很显然,当q1[k]没有被弹出的时候,另外两个数也都不能被弹出
(否则q2中的数字顺序就不是1,2,3,…,n了). 
而之后,无论其它的数字在什么时候被弹出,q1[j]总是会在q1[i]之前弹出.而q1[j]>q1[i],这显然是不正确的. 
接下来证明必要性.也就是,如果两个数不可以压入同一个栈,那么它们一定满足条件p.
这里我们来证明它的逆否命题,也就是"如果不满足条件p,那么这两个数一定可以压入同一个栈." 
不满足条件p有两种情况:一种是对于任意i<j<k且q1[i]<q1[j],q1[k]>q1[i];另一种是对于任意i<j,q1[i]>q1[j]. 
第一种情况下,很显然,在q1[k]被压入栈的时候,q1[i]已经被弹出栈.那么,q1[k]不会对q1[j]产生任何影响
(这里可能有点乱,因为看起来,当q1[j]<q1[k]的时候,是会有影响的,但实际上,这还需要另一个数r,
满足j<k<r且q1[r]<q1[j]<q1[k],也就是证明充分性的时候所说的情况…而事实上我们现在并不考虑这个r,
所以说q1[k]对q1[j]没有影响). 
第二种情况下,我们可以发现这其实就是一个降序序列,所以所有数字都可以压入同一个栈. 
这样,原命题的逆否命题得证,所以原命题得证. 
}
结论P: S[i],S[j]两个元素不能进入同一个栈 <=> 存在k,满足i<j<k,使得S[k]<S[i]<S[j]. 
那么我们知道了这个定理，就自然会想到对于满足P的两个点中间连一条无向边，表示两个点不可能在一个栈中
ORZ这就成了一道经典的二分图模型了(想到这这道题差不多就对了一半多了)
把每个元素按照输入序列中的顺序编号,看作一个图中的每个顶点.这时,我们对所有的(i,j)满足i<j,判断是否满足结论P,
即S[i],S[j]两个元素能否进入同一个栈.如果满足P,则在i,j之间连接一条边.
但是我们发现在判断数对(i,j)是否满足P时,枚举检查是否存在k的时间复杂度是O(n),则总的时间复杂度是O(n^3),
对于n=1000是太大了.这原因在于过多得枚举了k,我们可以用动态规划把枚举k变为O(1)的算法.
设F[i]为Min{S[i],S[i+1],S[i+2]..S[n-1],S[n]},状态转移方程为F[i]=Min{ S[i] , F[i+1] }.
边界为F[N+1]=INF.(也可以将F[n]设为a[n]，然后从n-1开始推)
事实上F[n+1]设为INF就是为了能推出正确的F[n]
判断数对(i,j)是否满足P,只需判断(S[i]<S[j] 并且 F[j+1]<S[i])即可.时间复杂度为O(n^2).
那么我们已经建立了无向图后，就开始先考虑怎样判断是否是一个可双栈排序的数列？
QAQ我们来对该图进行二分染色，由于只有两个栈,我们得到的图必须是二分图才能满足条件.
由于要求字典序最小,即尽量要进入栈1,我们按编号递增的顺序从每个未染色的顶点开始染色,
相邻的顶点染上不同的色,如果发生冲突,则是无解的.否则我们可以得到每个顶点颜色,即应该进入的栈1或2
染色处理完排除了不可双栈排序的数列后
我们继续考虑如何输出操作序列
其实直接模拟就好了，我们先设now=1表示现在应当出栈的数
我们从走到右扫描数列，如果该点染色为1，则入1栈，否则入2栈
注意每入一次栈都要判断一下当前入栈的是否是现在应该出栈的
如果是的话一言不合就把他出栈，now++
细节上我们要注意，判断出栈的时候应用while循环，因为可能now+1就在刚入栈的那个数下面
如果只出了当前now栈那么下次进入了一个新元素，你的now+1就永远卡死在栈中了
嗯这就是大致思路，还要注意一下建图+染色结点的方法
细节上要多注意边数组必须要开大很多(多开点咱不怂)
详细见代码吧~
														Powder
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int INF=0x7fffff;
const int Maxn=1050;
int n,cnt;
int map[Maxn][Maxn];
int a[Maxn],f[Maxn],c[Maxn];
int stack1[Maxn],stack2[Maxn];

void connect(int i,int j)
{
	map[i][j]=map[j][i]=1;
}

int dfs(int x,int cl)
{
	c[x]=cl;
	for(int i=1;i<=n;i++)
	{
		if(map[x][i])
		{
			if(!c[i])
			{
				if(!dfs(i,3-cl))
					return 0;
			}
			else
				if(c[i]==cl)
					return 0;
		}
	}
	return 1;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	f[n+1]=INF;
	for(int i=n;i;i--)
		f[i]=min(f[i+1],a[i]);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			if(a[i]<a[j]&&f[j+1]<a[i])
				connect(i,j);
	for(int i=1;i<=n;i++)
		if(!c[i])
			if(!dfs(i,1))
			{
				cout<<0<<endl;
				return 0;
			}
	int now=1;
	int cur1=0,cur2=0;
	for(int i=1;i<=n;i++)
	{
		if(c[i]==1)
			cout<<"a ",stack1[++cur1]=a[i];
		else
			cout<<"c ",stack2[++cur2]=a[i];
		while(stack1[cur1]==now||stack2[cur2]==now)
		{
			if(stack1[cur1]==now)
				cout<<"b ",cur1--;
			else
				cout<<"d ",cur2--;
			now++;
		}
	}
	return 0;
}
     