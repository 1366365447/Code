/*
第二次接触状态压缩动态规划题目~还是太弱了
考虑如果m=1那么这就是一个普通的背包问题
如果m=5那么这可以视作一个多维背包问题
普通背包问题f[i,j]表示背包只对前i个物品进行考虑，当前背包最大容量为j获得的最大价值
如果m=5我们可以想到f[i,j1,j2,j3,j4,j5]表示只对前i个物品进行考虑，
当前5种背包最大容量分别为j1,j2,j3,j4,j5获得的最大价值
但是这样很不方便，而且并不能处理m=1~4的情况
最关键的是这个“V1*V2*V3*...*Vk”可以到达5000000，数组肯定开不下
于是我们想到可以把每个[j1,j2,j3,j4,j5]改变成一个唯一的数
就用哈希+秦九韶公式优化=状态压缩一下
也就是j1+j2*(v1+1)+j3*(v1+1)*(v2+1)+j4*(v1+1)*(v2+1)*(v3+1)+v5*(v1+1)*(v2+1)*(v3+1)*(v4+1)
貌似这题的话如果m<5可以直接补足5位
但是其它题就一个循环搞状态压缩就好
dx1=状态[a1,a2,a3,a4,a5]
dx2=状态[a1-v[1],a2-v[2],a3-v[3],a4-v[4],a5-v[5]]，v[i]是用一个药品的效果值
就是一个背包问题的DP方法
就跟一维背包f[i,j]和f[i,j-w]一样
这样貌似就非常简单了~
主要思路是要想到用哈希压缩做背包，编程难度非常低
                                                Powder
*/
#include <cstdio>  
#include <iostream>
using namespace std;

const int M = 1e7 + 20;  
int dp[M], f[6], v[6];  
int n,m;

int main()  
{  
    cin>>n>>m; 
    for(int i = 1; i <= m; i++)  
        cin>>f[i]; 
    int ans = 0;  
    while(n--)  
    {  
        for(int i = 0; i <= m; i++)  
            cin>>v[i]; //v[0]为能力提高值，v[1]-v[m]为指标提升度
        for(int a1 = f[1]; a1 >= v[1]; a1--)  
            for(int a2 = f[2]; a2 >= v[2]; a2--)  
                for(int a3 = f[3]; a3 >= v[3]; a3--)  
                    for(int a4 = f[4]; a4 >= v[4]; a4--)  
                        for(int a5 = f[5]; a5 >= v[5]; a5--)  
                        {  
                            int dx1 = (((a1 * (f[2] + 1) + a2) *(f[3] + 1) + a3) * (f[4] + 1) + a4) * (f[5] + 1) + a5;  
                            int dx2 = ((((a1 - v[1]) * (f[2] + 1) + (a2 - v[2])) *(f[3] + 1) + (a3 - v[3])) * (f[4] + 1) + (a4 - v[4])) * (f[5] + 1) + a5 - v[5];  
                            if(dp[dx2] + v[0] > dp[dx1])  //选了后加上能力提升值v[0]
                            {  
                                dp[dx1] = dp[dx2] + v[0];  
                                if(dp[dx1] > ans)  //找最大值
                                    ans = dp[dx1];  
                            }  
                        }  
    }  
    cout<<ans<<endl;
    return 0;
}  