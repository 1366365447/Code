/*
哎我这个沙茶 没想到递归边界啊
Orz一道类似于编辑距离的题目，一道典型的线性动归。
看到一个很棒的题解，我就懒得写了
直接贴上来咯
字符串A和B的扩展串最大长度是A和B的长度之和。如字符串A为“abcbd”，字符串B为“bbcd”，
它们的长度分别是la=5、lb=4，则它们的扩展串长度最大值为LA+LB=9，
即A的扩展串的5个字符分别对应B的扩展串中的5个空格，
相应B的扩展串的4个字符对应A的扩展串中的4个空格。
例如下面是两个字符串的长度为9的扩展串：
a□b c□b□d□
□b□□b□c□d
而A和B的最短扩展串长度为la与lb的较大者，下面是A和B的长度最短的扩展串：
a b cbd
b□bcd
因此，两个字符串的等长扩展串的数量是非常大的，寻找最佳“匹配”
（对应位置字符距离和最小）的任务十分繁重，用穷举法无法忍受，
何况本题字符串长度达到2000，巨大的数据规模，势必启发我们必须寻求更有效的方法：
动态规划。
记<A1, A2, …, Ai>为A串中A1到Ai的一个扩展串，<B1, B2, …, Bj>为B串中B1到Bj的一个扩展串。
这两个扩展串形成最佳匹配的条件是
（1）长度一样；（2）对应位置字符距离之和最小。
首先分析扩展串<A1, A2, …, Ai>与扩展串<B1, B2, …, Bj>长度一样的构造方法。
扩展串<A1, A2, …, Ai>与扩展串<B1, B2, …, Bj>可以从下列三种情况扩张成等长：
（1）<A1, A2, …, Ai>与<B1, B2, …, Bj-1>为两个等长的扩展串，
则在<A1, A2, …, Ai>后加一空格，<B1, B2, …, Bj-1>加字符Bj；
（2）<A1, A2, …, Ai-1>与<B1, B2, …, Bj>为两个等长的扩展串，
则在<A1, A2, …, Ai-1>添加字符Ai，在<B1, B2, …, Bj>后加一空格；
（3）<A1, A2, …, Ai-1>与<B1, B2, …, Bj-1>为两个等长的扩展串，
则在<A1, A2, …, Ai-1>后添加字符Ai，在<B1, B2, …, Bj-1>后添加字符Bj。
其次，如何使扩展成等长的这两个扩展串为最佳匹配，即对应位置字符距离之和最小，
其前提是上述三种扩展方法中，被扩展的三对等长的扩展串都应该是最佳匹配，
以这三种扩展方法形成的等长扩展串(A1, A2, …, Ai>和<B1, B2, …, Bj>也有三种不同情形，
其中对应位置字符距离之和最小的是最佳匹配。
为了能量化上述的构造过程，
引入记号g[i, j]为字符串A的子串A1, A2, …, Ai与字符串B的子串B1, B2, …, Bj的距离，
也就是扩展串<A1, A2, …, Ai>与扩展串<B1, B2, …, Bj>是一个最佳匹配。则有下列状态转移方程：
g[i, j]=Min{g[i-1, j]+k, g[i, j-1]+k, g[i-1, j-1]+ c} 0≤i≤La 0≤j≤Lb
其中，k位字符与字符之间的距离； 为字符ai与字符bi的距离。
初始值：g[0, 0]=0 g[0, j]=j*k g[i, 0]=i*k
嗯讲解的非常详细了，
首先考虑阶段的划分，A、B两串前面连续多少个字符是具备明显后效性的，
也就是说取A的前i个和B的前j个所计算出来的最优值与后面如果引用此结构怎么放是没有影响的，
所以用A的前I个和B的前J个连续字符来划分阶段是正确的，因为两串长度都不超2000，2000^2不会超时。
下面来考虑情况：f要么把a[i]配到一起b[j]，则有f+a[i]和b[j]间的距离，如果不配到一起，
就把a[i]或b[j]中的一个单独处理加k值。
【方程】F=Min{f+abs(ord(a[i])-ord(b[j])),f+k,f+k}
注意初始值吧 因为i前面还有i-1个字符此时也对着空，所以f:=f+k,又f[0,0]:=k，故f:=k*i。f[0,i]同理
话说这题的样例很善良。。没有想到这个边界样例就会WA。。
水题，我也是个水人
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iomanip>
#include <cstdlib>
using namespace std;

const int maxn=2005;
string a1,b1;
int a[maxn],b[maxn];
int k,n,m;
int ans;
char ch;
int f[maxn][maxn];

void init()
{
	memset(f,0x37,sizeof(f));
	cin>>a1>>b1>>k;
	n=a1.length();
	m=b1.length();
	for(int i=0;i<n;i++)
		a[i+1]=a1[i]-'a';
	for(int i=0;i<m;i++)
		b[i+1]=b1[i]-'a';
	f[0][0]=0;
	for(int i=1;i<=m;i++)
		f[0][i]=f[0][i-1]+k;
	for(int i=1;i<=n;i++)
		f[i][0]=f[i-1][0]+k;
}

int main()
{
	init();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			f[i][j]=min(f[i-1][j-1]+abs(a[i]-b[j]),min(f[i-1][j],f[i][j-1])+k);
	cout<<f[n][m]<<endl;
	return 0;
}
     