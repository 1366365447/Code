/*
一道很久的NOIP的梗了
看到最大怒气值最小就可以想到二分
仔细一想也是有单调性的所以可以二分+二分图染色做
但是我们其实可以用并查集更好的解决
一个月前的窝写下了这个程序
那个时候还一脸懵逼看不懂边写边抄写完了这个程序
现在拆点什么的瞬间都明白了
OTZ果然一个月让人蜕变(也的确是让我的文化课蜕变2333)
我们来看一下这道题的并查集做法
首先我们用结构体来储存一下这个怨气关系
然后我们考虑贪心做法
怎么贪心？
我们这样看了	我们知道如果是要最大怨气值最小
我们不用关系一些小的怨气值会怎么样
我们直接关系这个最大的怨气值怎么能最小
我们就可以贪心选择最大的怨气值不要在同一个监狱
知道有一个不满足前面的条件了	那这个不满足的怨气值就肯定是最大怨气值的最优解了
所以我们先按边排序
然后并查集来判断是否可以满足不在同一监狱
很明显对立面的拆点做法
因为只有两个监狱	所以a,b要么在一个监狱要么不在一个监狱
我们用a+n来表示a的对立面
如果a,b在同一个监狱
那么肯定是a,b在同一个集合	a+n,b+n在同一个集合
同理如果a,b不在同一个监狱
那么肯定有a,b+n在同一个集合 a+n,b在同一个集合
所以我们可以进行拆点做了
拆点的题目有很多了我别的题解也写的很详细了
这里也不想累赘	毕竟这个拆点很简单
只想说的是我们注意这个拆点的适用范围
一定是只有两个属性即可以直接爆着对立面来写的
三个属性应该也能写但是窝太弱没写过
所以这道题就迎刃而解了
我们只需要按怨气值从大到小走一遍
不断地判断a,b能否不在一个监狱，如果可以，将彼此和对方的对立面合并集合
如果不可以，直接输出这个怨气值即为答案
OTZ然后就做完了
然后
你就AC了这道水题
然后
你就要去继续苦逼地做下一道水题了
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

struct node
{
	int x,y,v;
}a[100005];
int fa[40005];
int n,m;

int cmp(node a,node b)
{
	return a.v>b.v;
}

int getfather(int x)
{
	return fa[x]==x?x:fa[x]=getfather(fa[x]);
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		cin>>a[i].x>>a[i].y>>a[i].v;
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=2*n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int p=getfather(a[i].x);
		int q=getfather(a[i].y);
		if(p==q)
		{
			cout<<a[i].v<<endl;
			return 0;
		}
		fa[p]=getfather(a[i].y+n);
		fa[q]=getfather(a[i].x+n);
	}
	cout<<"0"<<endl;
	return 0;
}
     