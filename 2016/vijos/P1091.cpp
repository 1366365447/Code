/*
好奇妙的做法啊QAQ
根本想不通为啥想了半天
用sum[i]表示由第1个加油站开始开到第i+1个加油站途中把1~i加油站的油全加了
然后油箱所剩的油为多少
sum[i]有可能<0,且显然sum[0]与sum[n]都等于0,然后找出t=min(sum[i]){i=1..n}
..那么当sum[x-1]=t时,x就是其中1个答案[x=1..n] 
证明：
a[i]--站点i的油所能走的距离-i到站点i+1的距离
当sum最小则,a[i]+a+..a[n]=-sum(因为a[1]+...+a[i]要为sum而和为0)
则可知道.a[i]+a+..a[k]>0对于任意(i<=k<=n)必然成立
否则sum不为最小值..所以当sum[x-1]=t时x就为一解

这种方法好像是最简单但是很难想到的吧
还有单调队列 O(n)的动规算法等
对于环我们可以把它复制粘在后面。
然后我们对于每一个加油站，设置一个a[]表示在这一个加油站加的油减去从这个加油站开到另一个加油站的差。
那么我们要想选定某个加油站i作为起点，问题就变成了从i到i+n能够中间不断油，不断油的表现就是对于路径上的任何一个
加油站k，有a[i]+a[i+1]...+a[k]>0，我们维护一个前缀和s[i]=a[1]+a[2]+a[3]+...a[i]，那么a[i]+a[i+1]+..+a[k]=
s[k]-s[i-1]，我们枚举加油点i作为起点，那么我们的问题就是检验i<k<=i+n，都有s[k]-s[i-1]>0，这个问题只要我们检验s[k]中的最小值就可以解决了。那么s[k]的最小值可以用什么迅速求呢？单调队列！它的均摊复杂度就是O(1)的...然后
我们直接枚举1~n-1的每一个加油站作为起点，然后从它的区间里面用单调队列找出最小值，判断它们的差是否大于0即可。
O(n)的动归。

由于是个环，先把他复制一遍放到后面。然后，第i个点能环游的条件是能从这点走到第i+n点。

我们设一个函数f[i]=(k,left)表示从第i个点向后走最多能走到第k个点，并剩下可走left长度的油。

显然，i能环游的条件是f[i].k>=i+n

下面是状态转移。
1：先置k=i表示当前在k处。再置left=s[i]表示当前剩余油量。
2：如果left<D[k+1]那么就是说当前油量不够走到下一个节点，跳出循环。
　　否则：
　　　　left:=left-D[k+1]+f[k+1].left //先走到k+1处然后从k+1点向后走
　　　　k:=f[k+1].k //在k+1点时按f[k+1]的走法走。
　　然后，由于可能当前剩余油量仍够继续走下去，所以重复第2步。

循环结束后的k就是从i点最多能向后达到的节点编号，left为剩余油量。

算法复杂度：
在转移f[i]时，我们把f,f等作为一个整体来考虑，相当于将i+1,i+2……n分成了几个块，然后每个块最多处理一次。
设h[i]表示转移f[i]时向后走过了h[i]个块，即合并了h[i]个块。
再设g[i]表示在算f[i]时,i到n之间被划分成了g[i]个块。
那么g[i]=g+1-h
即：g-g[i]=h-1
所以g[n]=∑h[i]-n
由于g[n]=0，所以，∑h[i]=n
故总的复杂度为O(n)。
*/
#include <iostream>
using namespace std;

const int MAXN=500005;
int n,L;
int d,s;
int sum[MAXN];
int Min=0x7fffffff;

int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>L;
	if(n==1)
	{
		cout<<1<<endl;
		return 0;
	}
	cin>>d;
	for(int i=2;i<=n;i++)
	{
		cin>>s>>d;
		sum[i]=sum[i-1]+s-d;
		if(sum[i]<Min)	Min=sum[i];
	}
	for(int i=1;i<=n;i++)
		if(sum[i]==Min)
			cout<<i<<" ";
	return 0;
}
     