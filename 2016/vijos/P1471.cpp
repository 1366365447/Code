/*
O(N) 算法：
首先从左向右找到最左边的能一步到达n+1点的点 设这个点为I，
以这个I点为左边界，以n点为右边界，这个区间内的点只有两种情况：
1.如果能直接跳到n+1点 那么步数为1；
2.否则步数为二（跳到I点然后到n+1点）；
然后以I-1点为右边界，继续向左找能一步到达I点的最左边的点，设为点J 
那么区间（J,I-1）内的点也只有两种情况：
1.如果能跳到I点 那么步数为 I点的步数+1，
2.如果跳不到，那么步数为I点步数+2（先跳到J点，再跳到I点）
以此类推，直到扫到左边界 复杂度O（n）；

教主的游乐场(park) 排序，贪心
//无论从哪个装置开始，若要跳跃次数最少，最多向左跳1次，
并且这1次是在一开始跳的，因为如果向右跳后再向左跳，那么显然这次向左能跳到的装置前面也可以跳到。//
那么每次跳跃则要选择一个能让下一步跳到的位置编号尽量大的装置，因为跳到第i个装置，它下一次的行动范围为[1, i+a[i]]，
所以显然要i+a[i]得到最大。这样可以得到60%的分数。
正因为每次选择一个能让下一步跳到的位置编号尽量大的装置总可以得到最优解，对于每个装置，
下一步能跳到的装置编号为i+a[i]（称之为右边界），那么若按右边界排序从大到小排序后，
每个装置为起点的答案就会是不下降的。若在k步能到达的装置里面选一个装置编号最小的i，那么对于k步内不可达的装置，
若右边界大等于i，那么它即为k+1步可达的，同样在里面选出个编号最小的。由于可以向左无限跳，所以不必考虑左边界。
1步可达的编号为n+1。
PS：抽象模型，每个装置变成区间[i, i+a[i]]，问题就变成了区间覆盖的变种。

选用第一种算法进行编程
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

int n,m;
int a[100005];
int Right;
int ans[100005];

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	Right=n;
	do
	{
		int k;
		for(k=1;k+a[k]<=Right;k++);
		for(int i=k;i<=Right;i++)
		{
			if(a[i]+i>Right)
				ans[i]=ans[Right+1]+1;
			else
				ans[i]=ans[Right+1]+2;
		}
		Right=k-1;
	}
	while(Right>0);
	for(int i=1;i<=m;i++)
	{
		int l;
		cin>>l;
		cout<<ans[l];
		if(i!=m)
			cout<<" ";
	}
	return 0;
}

