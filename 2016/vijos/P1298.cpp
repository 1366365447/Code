/*
只有一堆时先手必胜。
有两堆时若两堆相等则后手只用和先手一样决策即可保证胜利，后手必胜。
若不同则先手可以使其变成相等的两堆，先手必胜。
有三堆时先手只用一次决策即可将其变成两堆相等的局面，先手必胜。
有四堆时由于三堆必胜，无论先手后手都想逼对方取完其中一堆，而只有在四堆都为一颗时才会有人取完其中一堆，联系前面的结论可以发现，只有当四堆可以分成两两相等的两对时先手才会失败。
分析到这里，题目好像已经有了一些眉目了，凭借归纳猜想，我们猜测必败态的条件为“堆数为偶数（不妨设为2N），并且可以分为两两相等的N对”。
下面只需证明一下这个猜想。其实证明这样的猜想很简单，只用检验是否满足必败态的三条性质即可。
首先，末状态为必败态，第一条性质符合。
其次，可以证明任何一个胜态都有策略变成必败态（分奇数堆和偶数堆两种情况讨论）。
最后，证明任何一个必败态都无法变成另一个必败态（比较简单）。
由于篇幅关系，这里就不具体证明了，如果有兴趣可以自己试试∶Ｐ
　 接下来的程序就相当简单了，只用判断一下即可。
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
  
int t,a[6000],n,k;

int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		if(n==1)
			cout<<"lolanv"<<endl;
		else
		{
			k=a[1];
			for(int j=2;j<=n;j++)
				k=(a[j]^k);
			if(k==0)
				cout<<"Wind"<<endl;
			else
				cout<<"lolanv"<<endl;
		}
	}
	return 0;
}