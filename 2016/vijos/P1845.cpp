/*
咳咳，这道题是有很高大上的做法
比如说nlogn的dp+线段树之类的
反正我是不想这么多。。。。
我们最容易知道的是
如果有相邻两朵花他们高度相同，肯定要拔掉一棵ORZ
那么我们就先处理一下数据，对于相邻的两朵高度相同的花就去掉，肯定不会影响最终答案
然后就直接不伦不类地"模拟"？
首先想到序列缩点，连续递减的点和连续递增的点是可以缩到一个代表性的点上的，
比如说样例给的5 3 2 1 2，，可以缩成5,1,2或3,1,2或2,1,2，
即5 3 2这三个连续递减的点实际上可以由一个点代替，1是一个转折点，
于是你也可以说是找转折点个数。
当找到转折点的个数后 后面必然有成立的点。用转折点的个数 加上后面成立的点的个数 
加上必然有一个点满足条件(题目中有说过)就可以在O(n）的时间内找出答案。
那么对于剩下的2~n个点扫一遍
找到转折点
再加上端点的两个
即ans1+ans2+2即可
*/
#include <cstdio>
#include <iostream>
using namespace std;
int n , h[ 100005 ] , ans1 , ans2 , tot , a[ 100005 ];
int main()
{
    cin>>n;
    for( int i = 1 ; i <= n ; i++ )
        cin>>h[i];
    tot = 1;
    a[ tot ] = h[ 1 ];
    for( int i = 2 ; i <= n ; i++ )
        if ( h[ i ] != h[ i - 1 ] )
            a[ ++tot ] = h[ i ];
    for( int i = 2 ; i < tot ; i++ )
    {
        if ( a[ i ] > a[ i - 1 ] && a[ i ] > a[ i + 1 ] ) ans1++;
        if ( a[ i ] < a[ i - 1 ] && a[ i ] < a[ i + 1 ] ) ans2++;
    }    
    cout<<ans1+ans2+2<<endl;
    return 0;
}