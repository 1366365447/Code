/*
经典DP了
将整数i分成j份，对1进行讨论
若每份都大于1，即先将i分出j来使每份为1，问题转化为将剩下的i-j分成j份的问题
若至少有一份为1，1已经占了一份，问题转化为将i-1分成j-1份的问题
设f[i][j]表示数i分成j份的划分方案数
可得f[i][j]=f[i-j][j]+f[i-1][j-1]
然后两个顺序递推就好了	初值f[0][0]=1	f[i][1]=1
这个第一个转移有点难理解啊
其实就是我们i分成j份
如果不包含1即每份都大于1	即每个拆出来的数都可以表示为x+1
所以我们相当于每个数加上了一个1上去
这样就完成了一个状态的转移
注意i>=j 因为不可能分的份数比自己还多OTZ
然后就推出来了
然后你就AC了此题
*/
#include <cstdio>
using namespace std;

int f[210][7];
int n,k,i,j;

int main()
{
    scanf("%d%d",&n,&k);
    f[0][0]=1;
    for(i=1;i<=n;i++)
    	f[i][1]= 1;
    for(i=1;i<=n;i++)
       	for(j=1;j<=k;j++)
         	if(i>=j)
 				f[i][j]=f[i-j][j]+f[i-1][j-1];
    printf("%d\n",f[n][k]);
	return 0;
}