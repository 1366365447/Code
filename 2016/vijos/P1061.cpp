/*
一道经典的线性动态规划问题，其中也利用了一个贪心的思想。
核心：相邻最优+倒序处理
设f[I,j]为前i个人分成j 组的最小值，其中这里的前i个人为高度前i高的人，与题目的前i个人有所不同。
那么我们有这样的状态转移方程：
F[I,j]=Min{f[i-1][j], f[i-2][j-1]+(a[i]-a[i-1])^2}
说明一下：
1.这里的f[i-1][j]表示不以较矮身份分i号人到组中
2.f[i-2][j-1]表示以a[i], a[i-1]为两个较矮的人分成一组(即当前此人和后面的一个人一组)
显然，在排好序后，取a,b时取相邻的总比取不相邻的要好。
这样我们就可通过计算公式求出“残疾程度”，那么就可以了。
而f[i-3,j-1]即默认了a[i-2], a[i-1]与a[i]形成一组，实际上残疾程度的计算与最高的人没有任何关系
所以是f[i-2,j-1]！
最关键的需要注意DP的方向。。
由于题目升序排序。。故而当前第i人是最高的。。这样会发生一个很悲剧的情况：
很有可能最后的几个二元组找不到补齐的第三人。。所以我们需要把数据倒过来处理。。
即i循环来倒推
这样就算最后几个人组成若干二元组。。由于n>=3*m成立所以必然可以找到对应的第三人。。
(这段话好好理解，对dp有很大帮助)
在有了a,b后，中间的那个人c，需要c>a,c>b，所以c的下标必在a,b前面，又因为a和b相邻
因此循环的时候要有j<=min(m,(n-i+1)/3)。
最后答案就是f[1][m]
嗯表示还是要好好多明白题目意思扩展思路
涨姿势了Orz
我写的代码是从后往前倒序的，所以状态转移方程有所不同
好好体会吧~
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iomanip>
#include <cstdlib>
using namespace std;

const int MAXN=5005;
int a[MAXN];
int f[MAXN][MAXN];//f[i][j]表示从后向前考虑到第i个人的时候分成j组的残疾程度最小值
int n,m;

void init()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
}

void DP()
{
    memset(f,0x37,sizeof(f));
    for(int i=1;i<=n;i++)
        f[i][0]=0;
    for(int i=n-2;i>=1;i--)//我们可以在状态转移方程中看到，枚举的j其实是是否用来当三个人中最矮的一个，所以要从n-2开始才对
        for(int j=1;j<=min(m,(n-i+1)/3);j++)
            f[i][j]=min(f[i+1][j],f[i+2][j-1]+(a[i]-a[i+1])*(a[i]-a[i+1]));
    printf("%d\n",f[1][m]);
}

int main()
{
    init();
    DP();
}
     